---
title: Заметки по курсу по основам Postgres
---

Несортировано и неинтересно.

Параметры типа `max_mem` выставляются на соединение. Соединений может быть много. Выходит нужно считать `max_mem_server = max_mem * max_connections`?

Есть не только кастомные функции (UDF), но и кастомные типы данных и кастомные индексы. Наверное прикольно, например, для IP адресов, хранимых в строке для челокоудобности, индекс на CIDR вкорячить.

## WAL

Никакой магии нет, есть вызов fsync при записи журнала с операциями на диск. Скорость досигается за счёт того, что последовательная потоковая (а не в случайное место на диске как в случае update) выполняется быстрее. Ну и затем фиксируется fsync, после чего можно уже считать транзакцию закоммиченной. Есть асинхронный режим, в котором пользователя обманывают - говорят что всё закоммитили, но где-то полсекунды всё будет в памяти, а затем walwriter запишет всё скопом. Оптимизация ценой надёжности. fsync работает пофайлово, т.е. вызов commit() в транзакции не вызовет синхронизацию ВООБЩЕ ВСЕГО БУФЕРА ВСЕХ ФАЙЛОВЫХ СИСТЕМ В СИНХРОННОМ РЕЖИМЕ и транзакция не зависнет в хлам. Но тут есть одно но - ОС, конечно скажет, fsync выполнен, т.к. он записывает буфер из памяти на диск. А у диска есть ещё свой буфер записи и при длительной потере питания он не факт что сохранится.
